<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>C-Sharp - Tag - Neil Fenwick | .NET, Go and Software Engineering</title><link>https://neilfenwick.net/tags/c-sharp/</link><description>C-Sharp - Tag - Neil Fenwick | .NET, Go and Software Engineering</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>neil.fenwick@gmail.com (Neil Fenwick)</managingEditor><webMaster>neil.fenwick@gmail.com (Neil Fenwick)</webMaster><copyright>Â© {year}</copyright><lastBuildDate>Tue, 04 Feb 2025 23:52:00 +0000</lastBuildDate><atom:link href="https://neilfenwick.net/tags/c-sharp/" rel="self" type="application/rss+xml"/><item><title>Rethinking Exceptions</title><link>https://neilfenwick.net/posts/rethinking-exceptions/</link><pubDate>Tue, 04 Feb 2025 23:52:00 +0000</pubDate><author>Neil Fenwick</author><guid>https://neilfenwick.net/posts/rethinking-exceptions/</guid><description>Why do newer programming languages like Go, Rust and Zig eschew Exceptions, believing that they cause unpredictable control flow and hidden performance costs? Instead they encourage explicit error tracking. Even Kotlin prefers a more functional style of error handling over unchecked exceptions.
Whether you&amp;rsquo;ve been working with C# for just a few months, or for several years, have you ever stopped to consider the way that you write code to handle errors?</description></item></channel></rss>